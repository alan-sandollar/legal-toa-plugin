/* THIS IS A GENERATED/BUNDLED FILE BY ESBUILD */
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableOfAuthoritiesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var TableOfAuthoritiesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Table of Authorities Plugin v17.4");
    this.addCommand({
      id: "generate-toa",
      name: "Generate Table of Authorities",
      editorCallback: (editor, view) => {
        const text = editor.getValue();
        const toaMarkdown = this.generateToa(text);
        if (!toaMarkdown) {
          new import_obsidian.Notice("No authorities found to extract.");
          return;
        }
        const currentCursor = editor.getCursor();
        const docEnd = editor.lastLine();
        const lastLineLength = editor.getLine(docEnd).length;
        editor.replaceRange(
          `

${toaMarkdown}`,
          { line: docEnd, ch: lastLineLength }
        );
        new import_obsidian.Notice("Table of Authorities v17.4 generated successfully!");
      }
    });
  }
  generateToa(text) {
    const statutePattern = /(?:\[?(?:Conn\.)?Gen\.Stat\.(?:[ \t\xA0]*§)?\]?[ \t\xA0]*§?[ \t\xA0]*\d[\w\-]*(?:[ \t\xA0]*\([\w]+\))*[a-zA-Z\d]*|\d+[ \t\xA0]+U\.S\.[ \t\xA0]*(?:C\.|Code)[ \t\xA0]+§?[ \t\xA0]*\d[\w\-]*(?:[ \t\xA0]*\([\w]+\))*[a-zA-Z\d]*)/gi;
    const otherPattern = /(?:Conn\.Civ\.J\.Instrn\.\s*[\d\.\-]+)/gi;
    const nameRegex = /([*_])(.*?)\1/gi;
    const payloadRegex = /^([ \t\xA0,]*?(?:\([^)]+\)[ \t\xA0]*)?(?:(?:(?:\d{1,2}:)?\d{2}-?[cC][vV]-?\d{3,7}(?:-[a-zA-Z]+)?)|(?:[a-zA-Z]{2,3}-[cC][vV]\d{2}-\d{4,8}-[a-zA-Z])|(?:\d{1,4}[ \t\xA0]+[a-zA-Z\.\d\s’']+(?:2d|3d|4th)?[ \t\xA0]+\d{1,5}))(?:[^()\[\]]*?)[\[\(][^\])]*\d{4}[\]\)](?:[ \t\xA0]*(?:\([^)]+\))?[ \t\xA0]*,[ \t\xA0]*[*_][a-zA-Z\.\s]+[*_][ \t\xA0]*,?[ \t\xA0]*\d{1,4}[ \t\xA0]+[a-zA-Z\.\d\s’']+[ \t\xA0]+\d{1,5}[ \t\xA0]*[\[\(][^\])]*\d{4}[\]\)])?)/i;
    const caseEntries = /* @__PURE__ */ new Map();
    const statuteEntries = /* @__PURE__ */ new Set();
    const otherEntries = /* @__PURE__ */ new Set();
    let match;
    while ((match = statutePattern.exec(text)) !== null) {
      statuteEntries.add(match[0].trim());
    }
    while ((match = otherPattern.exec(text)) !== null) {
      otherEntries.add(match[0].trim());
    }
    let caseMatch;
    while ((caseMatch = nameRegex.exec(text)) !== null) {
      let potentialName = caseMatch[2].trim();
      const endIdx = caseMatch.index + caseMatch[0].length;
      if (/^(see|cf|accord|id|at|ibid|supra|infra|cert\.?\s*denied|aff['’]d|rev['’]d)$/i.test(potentialName.toLowerCase())) continue;
      let cleanName = potentialName.replace(/^(?:See(?:, e\.g\.,?)?|Cf\.?|Accord|Concur)\s+/i, "").trim();
      if (cleanName.length < 4) continue;
      cleanName = cleanName.replace(/,$/, "");
      const lineRemainder = text.substring(endIdx).split("\n")[0];
      const payloadMatch = lineRemainder.match(payloadRegex);
      if (payloadMatch) {
        const cleanPayload = payloadMatch[1].replace(/^[ \t\xA0,]+/, "");
        const fullCite = `*${cleanName}*, ${cleanPayload}`;
        caseEntries.set(cleanName.toLowerCase(), fullCite);
      }
    }
    let toaString = "# Table of Authorities\n\n";
    let hasContent = false;
    if (caseEntries.size > 0) {
      toaString += "## Cases\n";
      const sortedCases = Array.from(caseEntries.values()).sort();
      sortedCases.forEach((c) => toaString += `${c}  
`);
      toaString += "\n";
      hasContent = true;
    }
    if (statuteEntries.size > 0) {
      toaString += "## Statutes\n";
      const sortedStatutes = Array.from(statuteEntries).sort();
      sortedStatutes.forEach((s) => toaString += `${s}  
`);
      toaString += "\n";
      hasContent = true;
    }
    if (otherEntries.size > 0) {
      toaString += "## Other\n";
      const sortedOthers = Array.from(otherEntries).sort();
      sortedOthers.forEach((o) => toaString += `${o}  
`);
      toaString += "\n";
      hasContent = true;
    }
    return hasContent ? toaString.trim() : "";
  }
};
